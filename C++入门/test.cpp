//#include<iostream>
//using namespace std;
//


//函数重载
//C语言是不允许同名函数存在的
//C++允许同名函数的存在

//函数的重载是定义在同一个作用域，要求参数不同，
//形参的不同包含，形参的类型不同，还可能个数不同
//还有就是参数的顺序不同
//如果两个参数的类型相同，但是形参的名称不同，也不能构成函数重载，因为形参只是实参的一个临时拷贝，也是一样的
//void Swap(int* pa, int* pb)
//{
//	int tmp = *pa;
//	*pa = *pb;
//	*pb = tmp;
//}
//void Swap(double* pa, double* pb)
//{
//	double tmp = *pa;
//	*pa = *pb;
//	*pb = tmp;
//}
//using之后两个函数，不需要重载关系，
//如果两个函数相同同时放在两个命名空间中，同时展开两个命名空间之后，会产生调用歧义
//函数重找是指统一个域中，就算是命名空间的展开也不构成函数重载，展开的意思是可以去找，但是不构成函数重载


//返回值不同，无法区分，不构成函数重载

//如果只有一个函数，调用的参数不同就存在隐式类型转换


//对于全缺省的无参的调用时会产生歧义
//int main()
//{
//	int a = 0,  b = 4;
//	double c = 1.2, d = 2.4;
//	Swap(&c, &d);
//	cout << c << " " << d;
//	Swap(&a, &b);
//	cout << a << " " << b;
//	return 0;
//}

//编译与链接的第一步是：预处理：展开头文件/宏替换/条件编译
//展开之后就会产生一个Stack.i和test.i的文件

//编译：检查语法，生成汇编代码生成Stack.s

//汇编代码是给我们看的，CPU看不懂

//最后进行一个过程汇编，汇编就是将汇编代码转换成二进制的机器码

//最后就是链接：生成可执行程序.exe的文件，Linux下生成的是a.out

//从编译开始之后两个文件是不会有交互的
//#include "Stack.h"
//int main()
//{
//	int a = 0;
//	int& b = a;
//	return 0;
//}


//引用的特性
//引用在定义的时候必须初始化
//一个变量可以有多个引用
#include<iostream>

//权限可以缩小但是不能放大
using namespace std;
int main()
{
	int a = 0;
	int& b = a;
	//b是a的别名，在当前作用域就是a的别名，不能改变指向
	const int m = 0;
	//int& n = m;//这里不能取引用
	//这里涉及到权限的放大
	//n变成我的别名，n的权限是可读可写，权限被放大了
	const int& n = m;
	return 0;
	//权限的缩小就可以，m不加const，然后引用加const
}